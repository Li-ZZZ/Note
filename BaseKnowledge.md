<link rel="stylesheet" type="text/css" href="mkcss.css">

![alt](https://img2018.cnblogs.com/blog/1271254/201907/1271254-20190706220449848-1411965352.png)  
# 线程和进程
每个进程都有独立的代码和数据空间。线程可以看成是轻量级的进程，属于同一进程的线程**共享代码**和**数据空间**。

**最根本区别**：进程是资源分配的单位，线程是调度和执行的单位  
**多进程**：在操作系统中能同时运行多个任务（程序）  
**多线程**：在同一应用程序中有多个顺序流同时进行

**程序计数器**：是一块内存区域，用来记录线程当前要执行的指令地址  
**栈**：用于存储该线程的局部变量，这些局部变量是该线程私有的，除此之外还用来存放线程的调用栈祯  
**堆**：是一个进程中最大的一块内存，堆是被进程中的所有线程共享的  
**方法区**：则用来存放 NM 加载的类、常量及静态变量等信息，也是线程共享的

![alt](https://img2018.cnblogs.com/blog/1251295/201907/1251295-20190701160656739-1817502298.png)  

### sleep
- 让当前线程休眠指定时间。
- 休眠时间的准确性依赖于系统时钟和CPU调度机制。
- 不释放已获取的**锁**资源，如果sleep方法在同步上下文中调用，那么其他线程 是无法进入到当前同步块或者同步方法中的。
- 可通过调用interrupt()方法来唤醒休眠线程。

### wait
- 让当前线程进入等待状态，当别的其他线程调用notify()或者notifyAll()方法时，当前线程进入就绪状态
- wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，前提是必须获取对象上的锁资源
- 当wait方法调用时，当前线程将会释放已获取的对象**锁**资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。 

# Synchronized 同步锁
https://blog.csdn.net/zjy15203167987/article/details/82531772
## 实现原理
**Synchronized**可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性

## Synchronized的三种应用方式
Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：
1. 普通同步方法（实例方法），锁是**当前实例**对象 ，进入同步代码前要获得当前实例的锁
2. 静态同步方法，锁是当前类的**class对象** ，进入同步代码前要获得当前类对象的锁
3. 同步方法块，锁是**括号**里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

例子见博客

## Synchronized的可重入性
Synchronized是可重入锁：  
当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。  
在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时，在**其方法体内部**调用该对象另一个synchronized方法，也就是说一个线程**得到一个对象锁后再次请求该对象锁**，是允许的，这就是synchronized的可重入性。  
需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过**可重入锁**调用父类的同步方法。

## Synchronized底层原理
https://blog.csdn.net/youanyyou/article/details/94514595  

### 代码块同步:  
每个对象有一个监视器锁（Monitor），当 Monitor 被占用时就会处于锁定状态。  
线程执行 Monitorenter 指令时尝试获取 Monitor 的所有权，过程如下：  
- 如果 Monitor 的进入数为 0，则该线程进入 Monitor，然后将进入数设置为 1，该线程即为 Monitor 的所有者。

- 如果线程已经占有该 Monitor，只是重新进入，则进入 Monitor 的进入数加 1。(可重入锁)

- 如果其他线程已经占用了 Monitor，则该线程进入阻塞状态，直到 Monitor 的进入数为 0，再重新尝试获取 Monitor 的所有权。

### 同步方法
相对于普通方法，其常量池中多了 **ACC_SYNCHRONIZED** 标示符。  
JVM 就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。   

如果设置了，执行线程将先获取 Monitor，获取成功之后才能执行方法体，方法执行完后再释放 Monitor。在方法执行期间，其他任何线程都无法再获得同一个 Monitor 对象。  

其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。