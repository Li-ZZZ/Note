<link rel="stylesheet" type="text/css" href="mkcss.css">

# Tcp
![alt](../pic/tcp-connect.png)

![alt](../pic/tcp-end.png)

TCP 协议需要一个四元组（源IP，源端口，目的IP，目的端口)

最多可有多少个tcp连接？  
客户端：每次发起请求，取一个空闲端口(16位)做连接,2^16  

服务端: 源IP(32位) * 源端口(16位) 固定监听一个ip和端口  
2^32*2^16   

但局限于允许的最大文件描述符(32位),linux中可修改  


## 为什么两次握手不行？

如果客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，服务器已正常关闭，再收到这个连接请求，再次开启浪费资源

## 如果某端突然断开，另一端怎么知道？

心跳机制。通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线，并传输一些可能必要的数据。系统默认是设置的2小时的心跳频率

心跳检测步骤:  
- 客户端每隔一个时间间隔发生一个探测包给服务器
- 客户端发包时启动一个超时定时器
- 服务器端接收到检测包，应该回应一个包
- 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
- 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

## 超时重传
RTT（Round Trip Time）：往返时延，也就是数据包从发出去到收到对应 ACK 的时间

RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。

超时后发送方重传数据包，接收方忽略重复数据包

## 确认应答机制 
TCP将每个字节的数据都进行了编号（序列号）  
seq表示当前数据的编号ack表示已确认的编号并期待对方接下来发送的数据编号

## 流量控制
接收端将自己可以接受的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK段通知发送端

## C++多态实现
基类函数加virtual，派生类重写  
c++编译器在编译的时候，要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。虚函数为晚绑定，在运行时确认函数地址

## 虚函数的底层实现机制
为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。

如果派生类没有重写，派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。

## 智能指针的实现
智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏

shared_ptr :  
实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用）,weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针,它只引用，不计数

unique_ptr：采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中

## define、const、inline
define：定义预编译时处理的宏,只进行简单的字符替换，无类型检测

inline: 内联函数对编译器提出建议，是否进行宏替换，编译器有权拒绝

const: 常量、编译器会进行类型检查

## 协程
协程效率比线程高，不需要切换到内核态，协程不需要多线程的锁机制。协程是在一个线程内进行切换，所以不存在同时写变量冲突，不需要给共享资源加锁，只需要判断状态。

## 进程通信  
管道：  
- 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
- 有亲缘关系的进程之间的通信

命名管道：
- FIFO可以在无关的进程之间交换数据
- FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中

消息队列：
- 消息的链接表，存放在内核中

信号量：
- 它是一个计数器。信号量用于实现进程间的互斥与同步
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。（原子操作）

共享内存：
- 最快的通信方式，直接映射内存地址，不用切换到内核态，多个进程可以同时操作，所以需要进行同步，

## 右值引用
看能不能对表达式取地址，如果能，则为左值，否则为右值。（临时变量，字面量）  
通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量的生命周期一样

移动构造：移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr

## map和unordered_map区别
map：排序、采用平衡树、复杂度logn、占用空间大
unordered_map：乱序、哈希表、复杂度O(1)、查找效率高

## C++中Struct与Class的区别
struct默认权限是public的，而class默认权限是private
在继承关系，struct默认是public的，而class是private  
struct不用使用模板、class可以
## C++继承
private 属性不能够被继承。  
使用private继承， 父类的protected和public属性在子类中变为private；  
使用protected继承，父类的protected和public属性在子类中变为protected；  
使用public继承， 父类的protected和public属性不发生改变;