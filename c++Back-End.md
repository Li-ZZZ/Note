<link rel="stylesheet" type="text/css" href="mkcss.css">

# Tcp
![alt](../pic/tcp-connect.png)

![alt](../pic/tcp-end.png)

TCP 协议需要一个四元组（源IP，源端口，目的IP，目的端口)

最多可有多少个tcp连接？  
客户端：每次发起请求，取一个空闲端口(16位)做连接,2^16  

服务端: 源IP(32位) * 源端口(16位) 固定监听一个ip和端口  
2^32*2^16   

但局限于允许的最大文件描述符(32位),linux中可修改  


## 为什么两次握手不行？

如果客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，服务器已正常关闭，再收到这个连接请求，再次开启浪费资源

## 如果某端突然断开，另一端怎么知道？

心跳机制。通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线，并传输一些可能必要的数据。系统默认是设置的2小时的心跳频率

心跳检测步骤:  
- 客户端每隔一个时间间隔发生一个探测包给服务器
- 客户端发包时启动一个超时定时器
- 服务器端接收到检测包，应该回应一个包
- 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器
- 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了

## 超时重传
RTT（Round Trip Time）：往返时延，也就是数据包从发出去到收到对应 ACK 的时间

RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间。

超时后发送方重传数据包，接收方忽略重复数据包

## 确认应答机制 
TCP将每个字节的数据都进行了编号（序列号）  
seq表示当前数据的编号ack表示已确认的编号并期待对方接下来发送的数据编号

## 流量控制
接收端将自己可以接受的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK段通知发送端

## C++多态实现
基类函数加virtual，派生类重写  
c++编译器在编译的时候，要确定每个对象调用的函数（非虚函数）的地址，这称为早期绑定，在基类中声明函数时使用virtual关键字，这样的函数我们就称之为虚函数，一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。虚函数为晚绑定，在运行时确认函数地址

## 虚函数的底层实现机制
为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针（vptr），这种数组成为虚函数表（virtual function table, vtbl），即，每个类使用一个虚函数表，每个类对象用一个虚表指针。

如果派生类没有重写，派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址。注意，如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中。

## 智能指针的实现
智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏

shared_ptr :  
实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用）,weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针,它只引用，不计数

unique_ptr：采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中

## define、const、inline
define：定义预编译时处理的宏,只进行简单的字符替换，无类型检测

inline: 内联函数对编译器提出建议，是否进行宏替换，编译器有权拒绝

const: 常量、编译器会进行类型检查

## 协程
协程效率比线程高，不需要切换到内核态，协程不需要多线程的锁机制。协程是在一个线程内进行切换，所以不存在同时写变量冲突，不需要给共享资源加锁，只需要判断状态。

## 进程通信  
管道：  
- 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端
- 有亲缘关系的进程之间的通信

命名管道：
- FIFO可以在无关的进程之间交换数据
- FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中

消息队列：
- 消息的链接表，存放在内核中

信号量：
- 它是一个计数器。信号量用于实现进程间的互斥与同步
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。（原子操作）

共享内存：
- 最快的通信方式，直接映射内存地址，不用切换到内核态，多个进程可以同时操作，所以需要进行同步，

## 右值引用
看能不能对表达式取地址，如果能，则为左值，否则为右值。（临时变量，字面量）  
通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量的生命周期一样

移动构造：移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr

## map和unordered_map区别
map：排序、采用平衡树、复杂度logn、占用空间大
unordered_map：乱序、哈希表、复杂度O(1)、查找效率高

## C++中Struct与Class的区别
struct默认权限是public的，而class默认权限是private
在继承关系，struct默认是public的，而class是private  
struct不用使用模板、class可以

## C++继承
private 属性不能够被继承。  
使用private继承， 父类的protected和public属性在子类中变为private；  
使用protected继承，父类的protected和public属性在子类中变为protected；  
使用public继承， 父类的protected和public属性不发生改变;

## 数据库ACID特性
- 原子性(Atomicity):事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。
- 一致性(Consistency):事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。
- 隔离性(Isolation):并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。
- 持久性(Durability):事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

## 数据库的并发错误
- 幻读是指事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致
- 脏读是指一个事务读取了另一个事务未提交的数据，因为回滚
- 不可重复读是指一个事务对同一数据的读取结果前后不一致
- 脏写是指事务回滚了其他事务对数据项的已提交修改

## 事务的隔离级别
级别由低到高，级别越低越有可能出现并发异常
- 读未提交(READ UNCOMMITTED)
- 读已提交(READ COMMITTED)
- 可重复读(REPEATABLE READ)
- 串行化(SERIALIZABLE)

## Tcp Reset
TCP的异常终止是相对于正常释放TCP连接的过程而言的，TCP在交互的过程中会出现一些意想不到的情况，导致TCP无法按照正常的四次挥手来释放连接，如果此时不通过其他的方式来释放TCP连接的话，这个TCP连接将会一直存在，占用系统的部分资源

## TCP粘包
TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

原因：
- 接收方：如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。
- 发送方：TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：
  - 只有上一个分组得到确认，才会发送下一个分组
  - 收集多个小分组，在一个确认到来时一起发送

解决方案：  
应用层循环处理接受的缓存
- 格式化数据：每条数据固定格式，有开头和结尾标志
- 发送长度：规定前4个字节为数据长度

## https
![alt](https://pic3.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_720w.png)
SSL证书中带有公钥  
客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：
1. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
3. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
4. 如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密
5. 浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充
7. 此时浏览器就可以读取证书中的公钥，用于后续加密了

